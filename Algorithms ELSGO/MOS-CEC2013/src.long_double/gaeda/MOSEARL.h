#ifndef MOSEARL_H
#define MOSEARL_H

#include <map>

#include "GAGeneticAlgorithm.h"
#include "MOSConfig.h"

class MOSConversion;
class MOSTechnique;
class MOSTechniqueSet;

/**
 * Class: MOSEARL
 *
 * @brief Description of MOSEARL algorithm.
 */
class MOSEARL : public GAGeneticAlgorithm {

 protected:

  typedef struct {
    std::string state;
    unsigned gen;
  } MapKey;

public:

  struct MapKeyComp {
    bool operator() (const MapKey& k1, const MapKey& k2) const {
      if (k1.gen < k2.gen)
	return true;
      else if (k1.gen > k2.gen)
	return false;
      else if (k1.state < k2.state)
	return true;
      else
	return false;
    }
  };

  struct PairComp {
    bool operator() (const std::pair<unsigned, long double>& p1,
		     const std::pair<unsigned, long double>& p2) const {
      if (p1.second < p2.second)
         return true;
      else
         return false;
    }
  } pairCmp;

  GADefineIdentity("MOSEARL", GAID::MOSRL);

  // Constructores
  MOSEARL(const GAGenome&         genome, const long double elitismPercent);
  MOSEARL(const GAPopulation& population, const long double elitismPercent);
  MOSEARL(const GAGeneticAlgorithm&  alg, const long double elitismPercent);

  ~MOSEARL();

  // Initialization of the alforithm
  void initialize();

  // Step a generation
  void step();

  // Create a new population from current one
  void offspring(GAPopulation* offpop) {};

  // Population size
  unsigned populationSize(unsigned size);

  // Returns a reference to the set of techniques used
  MOSTechniqueSet& getTechSet() const {return (MOSTechniqueSet&)*_techniqueSet;}

 protected:

  // Registers a new state in the QL matrix
  unsigned registerState(const std::vector<unsigned>& parts);

  // Selects the technique for the next offspring based on the QL matrix
  MOSTechnique* selectTechniquePMax(unsigned& action) const;

  // Selects the technique for the next offspring based on the Action Probability matrix
  MOSTechnique* selectTechniquePHCWoLF(unsigned& action) const;

  // Selects the best action (technique) in the given state
  unsigned bestTechnique(unsigned state) const;

  // Selects the worst action (technique) in the given state
  unsigned worstTechnique(unsigned state) const;

  // Updates quality and participation
  void updateQualityAndParticipation();

  // Scales given fitness within maximum and minimum fitness
  long double scaleFitness(long double fit) const;

  // Updates Action Probability for the PHC policy
  void updateActionProbabilityPHC(unsigned action);

  // Updates Action Probability for the WoLF policy
  void updateActionProbabilityWoLF(unsigned action);

  // Updates Average Policy Estimate for the WoLF policy
  void updateAveragePolicyEstimateWoLF();

  // Methods for printing, reading and writing the QL matrix
  void printQLMatrix() const;
  bool readRLFile   ();
  bool writeRLFile  () const;

 protected:

  typedef std::map<MapKey, unsigned, MapKeyComp> QLStatesT;

  // Attributes
  GAPopulation*    _auxPop;           // Aux population
  MOSTechniqueSet* _techniqueSet;     // Techniques Set
  MOSConversion*   _conversion;       // Encoding Conversion Functions
  long double           _elitismPercent;   // Percent of the old Pop brought
                                      // into the new one

  std::vector<unsigned> _parts;       // Discrete participation of techniques
                                      // in the current state
  std::vector<unsigned> _Inds;        // Individuals generated by each technique
  std::vector<unsigned> _partialInds; // Individuals generated by each technique (per generation)
  std::vector<long double> _avgFit;        // Fitness of individuals generated by each technique (per generation)
  unsigned _totalInds;                // Total number of individuals generated
                                      // by the algorithm
  int _state;                         // Cached current state
  unsigned _stateGen;                 // Current discretized generation used
                                      // in the states

  std::map<unsigned, MOSTechnique*> _techs; // Associative vector between techs
                                            // ptrs and techs ids (actions)

  QLStatesT _QLStates;                // Map with the state-matrix index
                                      // equivalence

  std::vector< std::vector<long double> > _QLearner; // Matrix with the QL
                                                // information

  std::vector< std::vector<long double> > _actionProb; // Matrix with the probability
                                                  // for selecting a technique

  std::vector< std::vector<long double> > _averagePolicyEstimate;

  std::vector<unsigned> _counter;

  std::vector< std::vector<unsigned> > _QLearnerCounter; // Matrix with the QL
                                                         // accounting info

  int _policy;

  long double ALFA;
  long double BETA;

  long double GAMMA;
  long double PMAX;

  long double DELTA;
  long double DELTA_L;
  long double DELTA_W;

};

#endif
