#include "MOSQualityFunction.h"

#include "GAPopulation.h"
#include "MOSTechnique.h"
#include "MOSTechniqueSet.h"
#include "extras/distaux.h"
#include "genomes/MOSGenome.h"
   #include <iomanip>
/**
 * Quality function: Average Fitness
 */
long double AverageFitnessQuality::averageFitness(const GAPopulation& pop, techIdType id, unsigned newInds) {

  unsigned nIndividualVector = 0;
  long double   acumQualityVector = 0.0;

  // Analize the population to retrieve the total number of individuals
  // generated by the given technique and their scores
  for (unsigned i = 0; i < pop.size(); i++) {
    MOSGenome& g = dynamic_cast<MOSGenome&> (pop.individual(i));
    if (g.getTechniqueId() == id) {
      nIndividualVector += 1;
      acumQualityVector += g.score();
    }
  }

  // Compute the average fitness of the given technique
  if (nIndividualVector > 0)
    return acumQualityVector / nIndividualVector;
  else
    return 0;

}


/**
 * Quality function: Average Fitness Increment
 */
long double AverageFitnessIncrementQuality::averageFitnessIncrement(const GAPopulation& pop, techIdType id, unsigned newInds) {

  unsigned nIndividualVector = 0;
  long double   acumQualityVector = 0.0;

  // Analize population to retrieve the total number of individuals
  // generated by the given technique and their fitness increments
  for (unsigned i = 0; i < pop.size(); i++) {
    MOSGenome& g = dynamic_cast<MOSGenome&> (pop.individual(i));
    if (g.getTechniqueId() == id && g.mustComputeQuality()) {
      nIndividualVector += 1;
      acumQualityVector += g.getFitnessIncrement();
      g.mustComputeQuality(false);
    }
  }

/*
  std::cout << setiosflags (ios::fixed | ios::showpoint) << setprecision(20);
  std::cout << MOSTechniqueSet::handle()->getTechnique(id)->getDescription() << std::endl;
  std::cout << "fit_inc_acum: " << acumQualityVector / newInds << std::endl;
  std::cout << "improvements: " << MOSTechniqueSet::handle()->getTechnique(id)->getTimesImproved() << std::endl;
  std::cout << "newInds: " << newInds << std::endl;
  std::cout << "weighted: " << (acumQualityVector / newInds) * (1 + (MOSTechniqueSet::handle()->getTechnique(id)->getTimesImproved() / newInds)) << std::endl;
*/
//  assert(nIndividualVector == newInds);

  // Compute the average fitness increment of the given technique
  if (nIndividualVector > 0) {
    return acumQualityVector / newInds;
    long double q = acumQualityVector / newInds;
//    return q * (1 + (MOSTechniqueSet::handle()->getTechnique(id)->getTimesImproved() / newInds));
//    return (MOSTechniqueSet::handle()->getTechnique(id)->getTimesImproved() / newInds);
  }
  else
    return 0;

}


/**
 * Quality function: Average Diversity
 */
long double AverageDiversityQuality::averageDiversity(const GAPopulation& pop, techIdType id, unsigned newInds) {

  vector<GAGenome*> subpop;

  for (unsigned i = 0; i < pop.size(); i++) {
    MOSGenome& ind = dynamic_cast<MOSGenome&>(pop.individual(i));
    if (ind.getTechniqueId() == id)
      subpop.push_back(&ind);
  }

  return computeDiversityAvg(subpop);

}


/**
 * Quality function: NSC
 */
/*
long double NSCQuality(const GAPopulation& pop, techIdType id, unsigned newInds) {
  return _nsc->computeNSC(pop, id);
}
*/
